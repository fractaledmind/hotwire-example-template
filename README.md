# Hotwire: Dynamic form fields with Turbo

[![Deploy to Heroku](https://www.herokucdn.com/deploy/button.png)][heroku-deploy-app]

[heroku-deploy-app]: https://heroku.com/deploy?template=https://github.com/thoughtbot/hotwire-example-template/tree/hotwire-example-turbo-dynamic-forms

Fetching fresh content from the server is one of the earliest problems a team
encounters when developing an interactive web application.

If they were build their application with a client-side rendering framework like
[React][], they might consider a line of questions like: "What's necessary to
include in our <abrr title="JavaScript Object Notation">JSON</abrr> schema? How
will my components render the data fetched from the server? Where will we [store
our application state][redux]?".

It's tempting to start with a similar, JavaScript- and JSON-centric line of
questions when building an application with [Hotwire][], [Turbo][], and
[Stimulus][] (for example, "How should my [Stimulus Controllers][] make [fetch
requests][]?").

Instead, it can be more fruitful to pose questions from an opposing perspective:
"How long could we wait before we introduce our first Stimulus Controller? What
would it take to build this without a [Turbo Stream][]? Could we defer to the
server for this? Would a full-page navigation work? Could these [fetch
requests][] be replaced with form submissions? What would it take to get started
on this feature without Stimulus, Turbo, or any JavaScript at all?".

[React]: https://reactjs.org
[redux]: https://redux.js.org
[Hotwire]: https://hotwired.dev
[Turbo]: https://turbo.hotwired.dev/
[Stimulus]: https://turbo.hotwired.dev/
[Stimulus Controllers]: https://stimulus.hotwired.dev/reference/controllers
[Turbo Stream]: https://turbo.hotwired.dev/handbook/streams
[fetch requests]: https://github.com/rails/request.js/tree/v0.0.6#how-to-use

## Why?

Each line of application code is as much of a liability as it is an asset. Teams
have [a finite "innovation token" budget][innovation-tokens] to spend on a
project. They should reserve the majority of that budget for differentiating
their product from the competition, and minimize the cost of inventing (or
re-inventing) Web technologies. Relying on browsers and Web protocols as much as
possible frees up time and attention to spend on what's most important: the
product.

Let's build a page to collect shipping information with [HTML Over the
Wire][Hotwire]. Our page will collect parts of the address (like street number,
apartment, city, and postal code) with text fields, and will present a list of
state options based on the currently selected country. Synchronizing the list of
states with the selected country will be the main focus of our exploration.

Our initial version will forego JavaScript entirely, and will rely on a
foundation of server-rendered HTML. We'll leverage button clicks, form
submissions, full-page navigations, and URL parameters to keep the list of state
options synchronized with the selected country. Then, we'll [progressively
enhance][] the page to automatically retrieve state options whenever country
selection changes.

The code samples shared in this article omit the majority of the application's
setup. The initial code was generated by executing `rails new`. The rest of the
[source code][] from this article (including a [suite of tests][]) can be found
on GitHub, and is best read either [commit-by-commit][], or as a [unified
diff][].

[innovation-tokens]: http://boringtechnology.club
[progressively enhance]: https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement
[Hotwire]: https://hotwired.dev
[source code]: https://github.com/thoughtbot/hotwire-example-template/tree/hotwire-example-turbo-dynamic-forms
[suite of tests]: https://github.com/thoughtbot/hotwire-example-template/tree/hotwire-example-turbo-dynamic-forms/test
[commit-by-commit]: https://github.com/thoughtbot/hotwire-example-template/commits/hotwire-example-turbo-dynamic-forms
[unified diff]: https://github.com/thoughtbot/hotwire-example-template/compare/hotwire-example-turbo-dynamic-forms

## Our starting point

We'll rely on the [city-state][] gem to provide the dataset of country and state
pairings. The `Address` class will serve as our main data model, and declares
[validations][] and convenience methods to access access `city-state`-provided
data through the `CS` class:

[city-state]: https://github.com/loureirorg/city-state/
[validations]: https://edgeguides.rubyonrails.org/active_record_validations.html

```ruby
class Address < ApplicationRecord
  with_options presence: true do
    validates :line_1
    validates :city
    validates :postal_code
  end

  validates :state, inclusion: { in: -> record { record.states.keys }, allow_blank: true },
                    presence: { if: -> record { record.states.present? } }

  def countries
    CS.countries.with_indifferent_access
  end

  def country_name
    countries[country]
  end

  def states
    CS.states(country).with_indifferent_access
  end

  def state_name
    states[state]
  end
end
```

The `app/views/addresses/new.html.erb` template renders a form that collects
`Address` information. The page renders `<input type="text">` elements to
collect street number (across a pair of "line" fields), city, and postal code.
The form renders a pair of `<select>` elements to collect the country and state.
Since our starting point won't support synchronizing the selected country and
its list of state options, the "Country" field is nested within a `<fieldset>`
element marked with the [`[disabled]`][fieldset-disabled] attribute so that it
remains unchanged. The United States is the default selection.

[fieldset]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/fieldset
[fieldset-disabled]: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/fieldset#attr-disabled

```erb
<%# app/views/addresses/new.html.erb %>

<section class="w-full max-w-lg">
  <h1>New address</h1>

  <%= render partial: "addresses/address", object: @address %>

  <%= form_with model: @address, class: "flex flex-col gap-2" do |form| %>
    <fieldset class="contents" disabled>
      <%= form.label :country %>
      <%= form.select :country, @address.countries.invert %>
    </fieldset>

    <%= form.label :line_1 %>
    <%= form.text_field :line_1 %>

    <%= form.label :line_2 %>
    <%= form.text_field :line_2 %>

    <%= form.label :city %>
    <%= form.text_field :city %>

    <%= form.label :state %>
    <%= form.select :state, @address.states.invert %>

    <%= form.label :postal_code %>
    <%= form.text_field :postal_code %>

    <%= form.button %>
  <% end %>
</section>
```

The `<fieldset>` element declares the [`.contents`][contents] Tailwind CSS
utility class (applying the [display: contents][] rule) so that its descendants
participate in the `<form>` element's [flexbox][] layout.

Outside the `<form>` element, the template renders the
`app/views/addresses/_address.html.erb` view partial to estimate a date of
arrival based on the selected country. The date formatted is with the
[`distance_of_time_in_words_to_now`][distance_of_time_in_words_to_now] view
helper:

```erb
<%# app/views/addresses/_address.html.erb %>

<aside id="<%= dom_id(address) %>">
  <p>Estimated arrival: <%= distance_of_time_in_words_to_now address.estimated_arrival_on %> from now.</p>
</aside>
```

In practice, the contents are irrelevant but, for our example's sake, represent
a server-side calculation that is unknowable to the client.

[distance_of_time_in_words_to_now]: https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/DateHelper.html#method-i-distance_of_time_in_words
[Stimulus Controller]: https://stimulus.hotwired.dev/reference/controllers
[display: contents]: https://developer.mozilla.org/en-US/docs/Web/CSS/display#box
[flexbox]: https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox
[contents]: https://tailwindcss.com/docs/display#contents

<img src="https://images.thoughtbot.com/blog-vellum-image-uploads/EHEwD8RJK10OMVt3cwOf_country-select-disabled.png"
     alt="A form collecting information about an Address with the Country select disable"
     height="720">

Clicking the `<button>` element submits a `POST /addresses` request to the
`AddresssesController#create` action. When the submission is valid, the record
is created, and the controller serves an [HTTP redirect response][redirect] to
the `AddressesController#show` route. When the submitted data is invalid, the
controller responds with a [422 Unprocessable Entity][422] status and re-renders
the `app/views/addresses/new.html.erb` template:

[422]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/422
[redirect]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections

```ruby
# app/controllers/addresses_controller.rb

class AddressesController < ApplicationController
  def new
    @address = Address.new
  end

  def create
    @address = Address.new address_params

    if @address.save
      redirect_to address_url(@address)
    else
      render :new, status: :unprocessable_entity
    end
  end

  def show
    @address = Address.find params[:id]
  end

  private

  def address_params
    params.require(:address).permit(
      :country,
      :line_1,
      :line_2,
      :city,
      :state,
      :postal_code,
    )
  end
end
```
